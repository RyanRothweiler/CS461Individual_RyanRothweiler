<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Improving Game Design Process</title><meta name="description" content="Game designers don’t seem to realize it, but the tools available to them are very poor. The process of game design is filled with…"><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Improving Game Design Process</h1>
</header>
<section data-field="subtitle" class="p-summary">
Game designers don’t seem to realize it, but the tools available to them are very poor. The process of game design is filled with…
</section>
<section data-field="body" class="e-content">
<section name="59aa" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="9ee4" id="9ee4" class="graf graf--h3 graf--leading graf--title">Improving Game Design Process</h3><p name="d9ec" id="d9ec" class="graf graf--p graf-after--h3">Game designers don’t seem to realize it, but the tools available to them are very poor. The process of game design is filled with difficulties and road blocks. I’m not talking about games as <em class="markup--em markup--p-em">software</em> development — I’m talking about games as <em class="markup--em markup--p-em">rulesets</em> design. The wants and desires of software developers are entirely separate from the wants and desires of a game designer, yet both use many of the same tools. Game ruleset designers need better tools if they want to push the boundaries of the medium.</p><p name="381b" id="381b" class="graf graf--p graf-after--p">When I say game ruleset designer, I mean a game designer concerned primarily with rulesets and interactive systems: I’m talking more about board games or strategy games and less about walking simulators or heavy execution games. The experiences of the latter are inseparable from the software, while games based on rules are not. For example, chess can be played with rocks on a beach, while StreetFighter can only be played on a computer which can run StreetFighter.</p><h3 name="e9e3" id="e9e3" class="graf graf--h3 graf-after--p">Current Typical Process</h3><p name="4c58" id="4c58" class="graf graf--p graf-after--h3">The game design process starts with ideas in the head of a designer, who then usually writes these ideas down into a design document, creating a more concrete ruleset. To prove the quality of these ideas the designer has two options. They can either make a paper prototype, or they can program the game into playable software. Both options are inherently problematic and a drain on the design process.</p><p name="d05c" id="d05c" class="graf graf--p graf-after--p">One option is to move from a design document to programming the rules into software. The biggest issue here is that this requires the designer to know how to write code. This is a massive time commitment: Acquiring the programming knowledge necessary to quickly iterate on a game design can take years. Even once acquired, game programming is entirely different from game design and it requires a different headspace. A game designer should not be required to also be a programmer.</p><p name="7105" id="7105" class="graf graf--p graf-after--p">Game designers often don’t program in their own game engines, because that is an even bigger time commitment, instead they use off-the-shelf packages like Unity or UnrealEngine. However, this makes the designs dependent on another software package: Without maintenance the game designs will be broken and unplayable in a few years.</p><p name="1186" id="1186" class="graf graf--p graf-after--p">If the designer decides they don’t want to spend years becoming a programmer, then they’ll then decide to prototype their ideas using paper. Though paper prototypes have their own major problems.</p><p name="c427" id="c427" class="graf graf--p graf-after--p">Creating a paper prototype is finicky and annoying. The designer must cut out paper in specific shapes and glue them onto other paper or cardboard shapes and sometimes print out grids or even draw the grid and then to play the game the designer must simultaneously run the game and play the game. Ideally the designer should be only playing the game while the rules should be managing themselves. Further, randomness is very annoying to simulate in a paper prototype. The designer must manage each varying type of randomness that the games mechanics require.</p><p name="cb6e" id="cb6e" class="graf graf--p graf-after--p">Even worse, some rulesets are impossible to paper prototype. A traditional fog of war mechanic is a good example here. Everybody knows what fog of war is, but managing it with paper is impossible since the player cannot know what is hidden by the fog of war. This discourages designers from working on certain mechanics, which is obviously a huge problem.</p><p name="4dc6" id="4dc6" class="graf graf--p graf-after--p">The real deal breaker with paper prototypes is the difficulty in playtesting. The designer must be in the same room as the playtester. This completely destroys the feedback loop inherent in design iteration and improvement.</p><p name="efff" id="efff" class="graf graf--p graf-after--p">While paper prototypes have unique problems, both prototyping solutions do have some similar problems. They both take the designer out the design head space since writing software or cutting paper require different skills than designing a game. This pulls designers away from the actual design itself and into thinking about cutting, gluing, or coding. An ideal toolset allows designers to focus entirely on the design.</p><p name="7840" id="7840" class="graf graf--p graf-after--p">All current prototyping tools completely lack archive-ability. Ideally a game prototype is reliably archivable. A designer must be able to explore an idea, put it away, and come back months or years later when something sparks their interest. Both systems fail in this goal. Paper prototypes require a complete accompanying rulebook to play. Because the rules are not enforced by the medium, it’s very easy to incorrectly play a paper prototype, especially when returning to it from some time away. Similarly, software rots over time: without constant maintenance, the life of a program is only a few years at best.</p><p name="561d" id="561d" class="graf graf--p graf-after--p">These problems are entirely unique to game design. No other artistic medium would allow these kinds of drains on their process. Writers and painters get to write and paint. They don’t have to learn an entirely separate skill before they’re able to create. Within minutes a musician can create a full listenable piece. At best a game designer can only fully test their idea after a few days.</p><h3 name="7416" id="7416" class="graf graf--h3 graf-after--p">Why should you care</h3><p name="571a" id="571a" class="graf graf--p graf-after--h3">I see this as a huge problem in game design. The medium of game design is weighed down by an anchor of poor process. Designers are unable to quickly and efficiently iterate on their idea which leeches the creativity and momentum of the entire process.</p><p name="0dda" id="0dda" class="graf graf--p graf-after--p">Also, these process problems scare away potentially outstanding game designers. It’s not hard to imagine someone filled with ideas, but lacking the technical programming skills necessary to implement them. This is a tragedy that will continue to slow the progress of game design until it is fixed.</p><p name="b67d" id="b67d" class="graf graf--p graf-after--p">Additionally, this lack of strong process slows the progress of games theory. I often read game design articles, claiming that games should do this, or games shouldn’t do that. But they almost never cite current games. That’s because it’s very difficult for designers to prove their theories. I can take years to build a game exemplifying your ideas. Again, this slows the entire medium. Game designers need a quicker iteration process if we want to increase the rate at which the games medium improves.</p><h3 name="935d" id="935d" class="graf graf--h3 graf-after--p">Possible Solutions</h3><p name="a456" id="a456" class="graf graf--p graf-after--h3">We’ve identified a problem. How are we going to fix it? Here are some solutions which have potential. These solutions help facilitate the strategy design process at the expense of games as software production. Thus these solutions are happy to sacrifice the typical software quality metrics for design expressiveness and iteration speed. The goal of these solutions is not a shippable piece of software but instead something different.</p><p name="a749" id="a749" class="graf graf--p graf-after--p">I’ve outlined those goals below. These metrics are ideals. Achieving every one of these with one tools is quite a difficult task, but it is important to be clear about what we want from our tools. Here are, what I think to be, the three most important metrics.</p><ul class="postList"><li name="54bf" id="54bf" class="graf graf--li graf-after--p">Archivable<br>Designers must be able to archive what they create. They must be test out an idea, put it away for months or years, and open it up again to resume work. They must be able to do this with a minimal time cost. This means the tool must be future proof. Anything created in the tools must be able to live forever into the future (this isn’t as hard as it sounds).</li><li name="c708" id="c708" class="graf graf--li graf-after--li">Expressive <br>The tools must be light and simple yet powerful. Designers need to be able to quickly and simply express ideas of complexity. This means very little ‘boiler plate’ work.</li><li name="1602" id="1602" class="graf graf--li graf-after--li">Light <br>This tool should allow designers create games in an exploratory way: testing, modifying and deleting need to be done quickly and easily. This means the software must be quick and light. Designers should never be waiting for the tool to do something. The tool should always be waiting for the designer.</li></ul><p name="c03d" id="c03d" class="graf graf--p graf-after--li">Alright, we have some ideal metrics and we know the problems with our current tools. Lets look at some possible solutions. As a warning, the solutions below are quite technical. I’ll do my best to explain them in a way anybody can understand. I also omit further in-depth explanation because of the complexity.</p><h3 name="ba7d" id="ba7d" class="graf graf--h3 graf-after--p">Big-library-o-code</h3><p name="1f7d" id="1f7d" class="graf graf--p graf-after--h3">One solution is to simply write and package the code which is used most commonly. This would speed-up the design process as the designer would be writing less code. Ideally the designer would have a visual editor which allows them to connect different pieces of this library into something meaningful. This would be something like Unity except explicitly focused on the design iteration process while ignoring the production of shippable software.</p><p name="e751" id="e751" class="graf graf--p graf-after--p">This is the most straight forward solution but is far from perfect. This solution does not solve any of the archival issues since the designs are necessarily dependent on the library in which it was produced. The nail in the coffin here is the lack of expressiveness. The only features your design can include are ones which were already thought of and implemented. This solution would speed the design process, but it would strangle designer’s creativity, producing a lot of very similar games.</p><h3 name="502b" id="502b" class="graf graf--h3 graf-after--p">GDL</h3><p name="cb6a" id="cb6a" class="graf graf--p graf-after--h3">Another promising avenue is the Game Description Language (GDL). GDL is a language which can rigorously encode any set of rules. It was developed to entirely encapsulate a game in a way that could be played by an artificial intelligence. Below is an example of the Monty Hall door game written in GDL-II.</p><figure name="3e05" id="3e05" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 240px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 34.300000000000004%;"></div><img class="graf-image" data-image-id="1*sZI0YG0gX4e7OcY-mx0wFg.png" data-width="1485" data-height="509" src="https://cdn-images-1.medium.com/max/800/1*sZI0YG0gX4e7OcY-mx0wFg.png"></div></figure><p name="cc34" id="cc34" class="graf graf--p graf-after--figure">GDL has many advantages. Because of its mathematical roots, it has been proven to express all possible games. This provides a sound theoretical foundation which truly unleashes the designer’s creativity. The language is quite simple which keeps the cost of entry low.</p><p name="c950" id="c950" class="graf graf--p graf-after--p">Importantly, GDL is completely uninterested in the computing necessary to run the game. It only declares the rules of the game, not how the rules are to be implemented on a computer. It is up to an entire different piece of software to run the game. This means GDL is completely future proof and perfectly archivable. A designer just needs to keep the GDL rules and the game will always be playable at any point in the future.</p><p name="4c50" id="4c50" class="graf graf--p graf-after--p">GDL has one big issue: it’s too minimal. Even creating something small requires a very large amount of writing — designing even basic board games in GDL is prohibitively difficult. The language is too verbose and too rigorous. It might be possible to solve this by extending the language with common design patterns but I think this gap is too large: So many new features are required that the result would effectively just be a different language.</p><h3 name="8fe4" id="8fe4" class="graf graf--h3 graf-after--p">ASP and Event Calculus</h3><p name="1f7a" id="1f7a" class="graf graf--p graf-after--h3">Another possible solution, which has a lot of promising research to behind it, is Answer Set Programming (ASP). Put simply, ASP is a programming paradigm focused on logically declaring problems in a way that can be solved by another program. Event Calculus is then built on top of that, and it allows for these problems to change through time. All of that is very complicated, and unfortunately, using this kind of prototyping tool would require knowledge of these complications.</p><p name="3df8" id="3df8" class="graf graf--p graf-after--p">This solution has many of the same problems as GDL, though not to the same degree. Expressing a game in ASP can come somewhat easily (though not as easily as I would want) however; there is no ASP language designed for games so they all have many unnecessary annoyances. For example, the language has no concept of time, or turns, so every line of the program has an annoying variable to manage the passage of time. ASP is a step in the right direction, but it is not quite there entirely.</p><h3 name="67ba" id="67ba" class="graf graf--h3 graf-after--p">New Language</h3><p name="8f3d" id="8f3d" class="graf graf--p graf-after--h3">Currently, there is no good solution. Though that isn’t surprising since nothing has been designed with games ruleset iteration in mind. I think the best solution is to design a new language with all the good and none of the bad. Obviously that is easier said than done. Complications always arise — however; it certainly seems possible.</p><p name="8ec3" id="8ec3" class="graf graf--p graf-after--p">This new language would be designed specifically for strategy game ruleset development. It would have an AnsProlog like semantics and syntax, but it would drop much of what is irrelevant, instead adopting features helpful for designers. Finally this new language would be declarative, so it will also be archivable. I’m happy to say I’m in the early stages of designing such a language. I don’t yet have anything demonstrable, but I’m making progress based on the goals and direction outlined above.</p><h3 name="e05e" id="e05e" class="graf graf--h3 graf-after--p">Process</h3><p name="b8dd" id="b8dd" class="graf graf--p graf-after--h3">Creating a new programming language sounds like the best solution, and that’s because I’ve defined it as such. There are no good tools for strategy games ruleset design. All current solutions are fraught with problems and none of them come close to achieving the metrics I outlined above. Part of the reason is because nobody has set out to specifically fix this problem. All current solutions are too abstract and general — game designers need a focused solution aimed at solving only their problems.</p><p name="c371" id="c371" class="graf graf--p graf-after--p graf--trailing">I think this is a big problem with the industry, yet it isn’t talked about enough. Game designers desperately need improved design tools. Such a tool would empower game designers, their ideas, and the entire industry.</p></div></div></section>
</section>
<footer><p class="p-tags">Tagged in <a href="https://medium.com/tag/game-design" class="p-tag">Game Design</a>, <a href="https://medium.com/tag/game-development" class="p-tag">Game Development</a>, <a href="https://medium.com/tag/board-games" class="p-tag">Board Games</a></p><p>By <a href="https://medium.com/@ryanrothweiler" class="p-author h-card">Ryan Rothweiler</a> on <a href="https://medium.com/p/9e392ebf73af"><time class="dt-published" datetime="2017-03-29T03:50:57.145Z">March 29, 2017</time></a>.</p><p>Exported from <a href="https://medium.com">Medium</a> on June 22, 2017.</p></footer></article>

</body></html>